use neon::prelude::*;
use std::fs::create_dir;
use std::path::PathBuf;

pub(crate) const APP_NAME: &'static str = "AppName";

macro_rules! export_enum {
    ($cx:ident, $enumeration:ident, [$(($variant:ident, $name:literal)),+]) => {
        $({
            let js_value = $cx.number($enumeration::$variant);
            $cx.export_value($name, js_value)?;
        })+
    };
}

#[repr(u8)]
enum Outcome {
    Success = 0,
    CreateDirFailed = 1,
}

impl From<Outcome> for f64 {
    fn from(outcome: Outcome) -> Self {
        outcome as u8 as f64
    }
}

impl Outcome {
    fn export(cx: &mut ModuleContext) -> NeonResult<()> {
        export_enum!(
            cx,
            Outcome,
            [(Success, "SUCCESS"), (CreateDirFailed, "CREATE_DIR_FAILED")]
        );
        Ok(())
    }
}

// Ideally, this function should be generated by a proc macro
fn js_init_app_dir(mut cx: FunctionContext) -> JsResult<JsNumber> {
    let app_data_path = PathBuf::from(cx.argument::<JsString>(0)?.value(&mut cx));
    Ok(cx.number(init_app_dir(app_data_path)))
}

fn init_app_dir(mut app_data_path: PathBuf) -> Outcome {
    use Outcome::*;

    dbg!(&app_data_path);

    app_data_path.push(APP_NAME);
    if app_data_path.exists() {
        return Success;
    } else if create_dir(&app_data_path).is_err() {
        return CreateDirFailed;
    };
    for img_fmt in ["nifti", "dicom"].iter() {
        app_data_path.push(img_fmt);
        if create_dir(&app_data_path).is_err() {
            return CreateDirFailed;
        };
        for res_kind in ["images", "masks"].iter() {
            app_data_path.push(res_kind);
            if create_dir(&app_data_path).is_err() {
                return CreateDirFailed;
            };
            app_data_path.pop();
        }
        app_data_path.pop();
    }
    Success
}

#[neon::main]
fn main(mut cx: ModuleContext) -> NeonResult<()> {
    cx.export_function("init_app_dir", js_init_app_dir)?;
    Outcome::export(&mut cx)?;
    Ok(())
}
